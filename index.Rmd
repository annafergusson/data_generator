---
title: Data generator
output: 
  html_document:
    includes:
      in_header: header.html
---

```{css echo=FALSE}
/* Absolute Center Spinner */
.loading {
  z-index: 999;
  overflow: show;
  margin: auto;
  display: block;
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background-color: rgba(0,0,0,0.3);
}

.title {
  display: none;
}

tr {
  border-top: 1px black solid !important;
  border-bottom: 1px black solid !important;
}

td {
  padding: 5px 10px 5px 10px !important;
  text-align: center;
}

.shadey {background: #F0F0F0}
    
.sectiony {margin-top: 20px;
  display:none;}
  
input {width: 60px}

.but {margin-left: 5px}
  
```

# {.tabset}

## One device

<div class='sectiony spinnery'>
<table id ='drv' style='float:left'>
<tr><td class='shadey'>Outcome</td></tr>
<tr><td class='shadey'>Weighting</td></tr>
</table>
<button class='but' onclick='addOutcome()'>+</button>
<button class='but' onclick='deleteOutcome()'>&#8211;</button>
<button class='but' onclick='setupSpinner()' id='updateDRV'>Update</button>
</div>

<div style='clear:both'></div>

<div class='sectiony spinnery'>
Randomise <input type='number' id='spin_num'> times
</div>

<div id='spinner-wrapper' style="position:relative;  width: 300px;
    height: 100px;" class='sectiony'>
<canvas id='spinner' style="position: absolute; left: 0; top: 0; z-index: 0;"></canvas>
<canvas id='pointer' style="position: absolute; left: 0; top: 0; z-index: 1;"></canvas>
</div>

<div class='sectiony' style='height:20px'>
<span id='outcome'></span>
</div>

<div class='sectiony'>
<p>Repeat <input type='number' id='trial_num'> times</p>
<p>Speed: <select id='speed'><option>slow</option><option>medium</option></select></p>
<button onclick='startSim()' id='startData'>Generate data</button>
</div>

## Two devices

<div class='sectiony spinnery'>
Not done yet!
</div>

```{js echo=FALSE}
$().ready(function(){

  // set interface
  var kAppName = "data generator";
  var kVersion = "1.0";
  var kDimensions = {width: 400, height: 600};
  
  codapInterface.init({
    title: kAppName,
    dimensions: kDimensions,
    version: kVersion,
    preventDataContextReorg: false,
  }).then(function (result) {
    myState = codapInterface.getInteractiveState();
  }).then(function () {
  // initialise tool
    if (myState.probs === undefined || myState.probs === null) {
      // set up default
      var outcomes = ["üê±","üê∂"];
      var probs = [80, 20];
      var total_spins = 1;
      var num_trials = 10;
      doSetup(outcomes, probs, total_spins, num_trials)
    }
    else
    {
  	  //use values saved in state to set options for the tool
      var outcomes = myState.outcomes;
      var probs = myState.probs;
      var total_spins = myState.total_spins;
      var num_trials = myState.num_trials;
      doSetup(outcomes, probs, total_spins, num_trials)
    }
    
  }).catch(function (msg) {
      //for testing outside CODAP
      var outcomes = ["üê±","üê∂"];
      var probs = [80, 20];
      var total_spins = 1;
      var num_trials = 10;
      doSetup(outcomes, probs, total_spins, num_trials)
  });
  
});

function doSetup(outcomes, probs, total_spins, num_trials){

  data_version = 1;
  prev_outcomes = [];
  prev_probs = [];
  prev_spins = 0;
  
  $("#spin_num").val(total_spins);
  $("#trial_num").val(num_trials);
  
  var table = document.getElementById('drv');
  for(var i = 0; i < probs.length; i++)
  {
    var cols =  table.rows[0].cells.length;
    var cell = table.rows[0].insertCell(cols);
    cell.innerHTML = outcomes[i];
    cell = table.rows[1].insertCell(cols);
    cell.innerHTML = probs[i];
  }

  //make the table editable
  $("td").prop("contenteditable", true);
  $("td").keyup(makeChange)
  setupSpinner();
  
}

function makeChange(){
   $('#startData').prop('disabled', true);
     $('#startData').css("opacity", 0.5);
     $('#updateDRV').css("background", "yellow");
     $('#updateDRV').css("border", "none");
     $('#updateDRV').show();
}

function addOutcome(){
  var table = document.getElementById('drv');
  var cols =  table.rows[0].cells.length;
  var cell = table.rows[0].insertCell(cols);
  cell.innerHTML = "?";
  cell = table.rows[1].insertCell(cols);
  cell.innerHTML = "10";
  $("td").prop("contenteditable", true);
  makeChange();
}

function deleteOutcome(){
  var table = document.getElementById('drv');
  var cols =  table.rows[0].cells.length;
  if(cols > 1){
    table.rows[0].deleteCell(cols - 1);
    table.rows[1].deleteCell(cols - 1);
  }
  makeChange();
}

function setupSpinner(){

  //data_version += 1;
  saveState();
  var canvas = document.getElementById("spinner");
  var context = canvas.getContext("2d");
  canvas.width = $("#spinner-wrapper").width();
  canvas.height = $("#spinner-wrapper").height();
  
  context.clearRect(0, 0, canvas.width, canvas.height);
  
  context.fillStyle = "#F0F0F0";
  context.strokeStyle = "black";
  context.beginPath();
  context.rect(0, 0, canvas.width, canvas.height);
  context.closePath();
  context.fill();
  context.stroke();
  
  //get details from DRV table
  var table = document.getElementById('drv');
  var lastProp = 0;
  
  //get sum of weightings
  var sumWeights = 0;
  for(var i = 1; i < table.rows[0].cells.length; i++)
  {
    //show the sector
    sumWeights += table.rows[1].cells[i].innerHTML * 1;
  }
  
  
  for(var i = 1; i < table.rows[0].cells.length; i++)
  {
    //show the sector
    var thisProp = table.rows[1].cells[i].innerHTML/sumWeights;
    var thisText = table.rows[0].cells[i].innerHTML;
    
    context.beginPath();
    context.moveTo(canvas.width * (lastProp + thisProp), 0);
    context.lineTo(canvas.width * (lastProp + thisProp), canvas.height);
    context.closePath();
    context.stroke();
    
    //show the text
    var x = canvas.width * ((thisProp)/2 + lastProp);
    var y = canvas.height/2;
    context.font = canvas.width * 0.05 + "px Arial";
    context.textAlign = "center";
    context.textBaseline = "middle";
    context.fillStyle = "#000000";
    context.fillText(thisText, x, y);
    
    lastProp += thisProp;
  }
  
  //draw pointer
  var canvas = document.getElementById("pointer");
  var context = canvas.getContext("2d");
  canvas.width = $("#spinner-wrapper").width();
  canvas.height = $("#spinner-wrapper").height();
  drawPointer(canvas, context, 0);
  
   $('#startData').prop('disabled', false);
   $('#startData').css("opacity", 1);
   $('#updateDRV').css("background", "");
   $(".sectiony").show();
   $('#updateDRV').hide();
}

function startSim(){
  saveState();
  super_data = [];
  var num_trials = $("#trial_num").val()*1;
  makeSpin(1, num_trials);
}

function makeSpin(this_trial, num_trials){
  $("#outcome").text("");
  data = {};
  var total_spins = $("#spin_num").val()*1;
  nextSpin(1, total_spins, 0, this_trial, num_trials);
}

function nextSpin(this_spin, total_spins, starting_prop, this_trial, num_trials){
  var canvas = document.getElementById("pointer");
  var context = canvas.getContext("2d");
  var table = document.getElementById('drv');
  var sumWeights = 0;
  for(var i = 1; i < table.rows[0].cells.length; i++)
  {
    //show the sector
    sumWeights += table.rows[1].cells[i].innerHTML * 1;
  }
  
  var outcomes = [];
  var probs = [];
  for(var i = 1; i < table.rows[0].cells.length; i++)
  {
    outcomes.push(table.rows[0].cells[i].innerHTML);
    probs.push(table.rows[1].cells[i].innerHTML/sumWeights);
  }
  var randProp = Math.random();
  var randOutcome = "";
  var cumProp = 0;
  for(var i = 0; i < outcomes.length; i++)
  {
      cumProp += probs[i];
      if(randProp < cumProp){
         randOutcome = outcomes[i]
         break;
      }
  }
  
  var speed = 0.1;
  if($("#speed").val() == "medium")
  {
    speed = 0.4;
  }
  spin(canvas, context, Math.max(starting_prop - 4, 0), randProp + 4, speed, randOutcome, this_spin, total_spins, this_trial, num_trials)
}

function spin(canvas, context, prop, max, speed, randOutcome, this_spin, total_spins, this_trial, num_trials){
  var wait = 10;
  if($("#speed").val() == "medium")
  {
    wait = 4;
  }
  
  if(prop < max)
  {
    drawPointer(canvas, context, prop);
    
    setTimeout(function(){
      spin(canvas, context, prop + speed, max, speed, randOutcome, this_spin, total_spins, this_trial, num_trials)
    }, wait)
  }
  else
  {
  //move if needed to max point
  setTimeout(function(){
      drawPointer(canvas, context, max)
    }, wait);
    
    $("#outcome").append(" " + randOutcome);
    var var_name = "val" + this_spin;
    data[var_name] = randOutcome;
    
    if(this_spin < total_spins)
    {
      var speed_time = wait*20;
      setTimeout(function(){nextSpin(this_spin + 1, total_spins, max % 2*Math.PI, this_trial, num_trials)}, speed_time)
    }
    else
    { 
      if(total_spins > 1)
      {
        var combine = "";
        for(var i = 1; i <= total_spins; i++)
        {
          combine = combine + data["val" + i];
          if(i < total_spins){combine = combine + " "}
        }
        data["vals"] = combine;
        
        //get this later
        var table = document.getElementById('drv');
        var outcomes = [];
        for(var i = 1; i < table.rows[0].cells.length; i++)
        {
          outcomes.push(table.rows[0].cells[i].innerHTML)
        }
        
        for(var i = 0; i < outcomes.length; i++)
        {
          var count = 0;
          for(var j = 1; j <= total_spins; j++)
          {
            if(data["val" + j] == outcomes[i]){count += 1}
          }
           data["count(" + outcomes[i] + ")"] = count;
        }
      }
      
     // alert(JSON.stringify(data));
      super_data.push(data);
      doStuff([data]); 
      if(this_trial < num_trials)
      {
        setTimeout(function(){makeSpin(this_trial + 1, num_trials)}, wait*40)
      }
      else
      {
        //doStuff(super_data); 
      }
    }
  }
}

function drawPointer(canvas, context, prop){
  if(prop > 1 && prop < 2){
     prop = 1 - (prop - 1);
  }
  if(prop >= 2 && prop < 3){
     prop = prop - 2;
  }
  if(prop >=3 && prop < 4){
    prop = 1 - (prop - 1);
  }
  if(prop >=4){
    prop = prop - 4;
  }
  
  context.clearRect(0, 0, canvas.width, canvas.height)
  context.lineWidth = canvas.width * 0.02;
  context.strokeStyle = "#666666";
  context.fillStyle = "#666666";
  context.beginPath();
  context.moveTo(prop*canvas.width,  canvas.height*0.85);
  context.lineTo(prop*canvas.width + 0.04*canvas.width, canvas.height);
  context.lineTo(prop*canvas.width - 0.04*canvas.width, canvas.height);
  context.lineTo(prop*canvas.width,  canvas.height*0.85);
  context.closePath();
  context.fill();
}

function saveState(){
  var table = document.getElementById('drv');
  var outcomes = [];
  var probs = [];
  for(var i = 1; i < table.rows[0].cells.length; i++)
  {
    outcomes.push(table.rows[0].cells[i].innerHTML);
    probs.push(table.rows[1].cells[i].innerHTML);
  }
  var num_trials = $("#trial_num").val()*1;
  var total_spins = $("#spin_num").val()*1;
  
  //save
  if (typeof myState !== 'undefined')
  {
    myState.outcomes = outcomes;
    myState.probs = probs;
    myState.num_trials = num_trials;
    myState.total_spins = total_spins;
  }
}

function doStuff(dataframe){
 
    var data = dataframe;
    var attributes = Object.keys(data[0]);
    
    var spins = $("#spin_num").val()*1;
    var table = document.getElementById('drv');
    var outcomes = [];
    var probs = [];
    for(var i = 1; i < table.rows[0].cells.length; i++)
    {
      outcomes.push(table.rows[0].cells[i].innerHTML);
      probs.push(table.rows[1].cells[i].innerHTML);
    }
    
    if(compareArrays(outcomes, prev_outcomes) && compareArrays(probs, prev_probs) && prev_spins == spins)
    {
      //no change
    }
    else
    {
      //change
      if(prev_outcomes.length > 0)
      { 
        data_version += 1;
      }
    }
        
    prev_outcomes = outcomes;
    prev_probs = probs;
    prev_spins = spins;
    
    var tableName = "generated_data" + data_version;
    
    var kAttributes = [];
    for(var i = 0; i < attributes.length; i++)
    {
      kAttributes.push({name: attributes[i]})
    }
    
    codapInterface.sendRequest({
        action:'get',
        resource: 'dataContext[' + tableName + ']'
      }).then(function(result){
        if (result && !result.success) {
          codapInterface.sendRequest({
      "action": "create",
      "resource": "dataContext",
      "values": {
        "name": tableName,
        "collections": [ {
          "name": tableName,
          "attrs": kAttributes
        }]
      }
    })
        } 
      }).then(function(){
      codapInterface.sendRequest({
      "action": "create",
      "resource": "dataContext[" + tableName + "].item",
       "values": data
    })
    }).then(function(){
       //guaranteeCaseTable(tableName)
       codapInterface.sendRequest({action: 'create', resource: 'component', values: {
            type: 'caseTable',
            dataContext: tableName
          }})
    })
}

function compareArrays(arrOne, arrTwo){
  result = false;
  if (arrOne.length === arrTwo.length) {
  for (let i = 0; i < arrOne.length; i++) {
    result = arrTwo.indexOf(arrOne[i]) !== -1;

    if (result === false) {
      break;
    }
  }
}
return result;
}

// from example CODAP plugin
function guaranteeCaseTable(name) {
  return new Promise(function (resolve, reject) {
    codapInterface.sendRequest({
      action: 'get',
      resource: 'componentList'
    })
    .then (function (iResult) {
      if (iResult.success) {
        // look for a case table in the list of components.
        if (iResult.values && iResult.values.some(function (component) {
              return component.type === 'caseTable'
            })) {
          resolve(iResult);
        } else {
          codapInterface.sendRequest({action: 'create', resource: 'component', values: {
            type: 'caseTable',
            dataContext: name
          }}).then(function (result) {
            resolve(result);
          });
        }
      } else {
        reject('api error');
      }
    })
  });
}



```